<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Boat Racer</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; 
    background: #0a192f;
    font-family: Arial, sans-serif;
    user-select:none; touch-action:none;
    color:#00fff7;
  }
  body::before {
    content: "";
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: 
      radial-gradient(circle at 20% 30%, rgba(255,255,255,0.1) 1px, transparent 1px),
      radial-gradient(circle at 80% 70%, rgba(255,255,255,0.1) 1px, transparent 1px);
    background-size: 50px 50px;
    z-index: -1;
  }
  #info {
    position: fixed; top: 10px; left: 10px; right:10px; height: 50px;
    display: flex; align-items: center; justify-content: space-around;
    font-weight: bold; font-size: 20px;
    text-shadow: 0 0 8px #00fff7;
    pointer-events: none;
  }
  #hearts {
    flex: 0 0 140px;
    display: flex;
    justify-content: space-between;
  }
  .heart {
    width: 28px;
    height: 28px;
    background: red;
    clip-path: polygon(
      50% 15%, 61% 10%, 75% 15%, 85% 27%, 85% 40%, 75% 55%,
      50% 80%, 25% 55%, 15% 40%, 15% 27%, 25% 15%, 39% 10%
    );
    filter: drop-shadow(0 0 5px #ff4d4d);
  }
  .heart.lost {
    background: #400000;
    filter: none;
  }
  button {
    background:#4AA1B0;
    border:none;
    color:#fff;
    font-weight:bold;
    font-size: 18px;
    padding: 10px 25px;
    margin: 10px;
    border-radius: 7px;
    cursor: pointer;
    box-shadow: 0 0 10px #4AA1B0;
    transition: background 0.3s ease;
  }
  button:hover {
    background:#73c2e9;
    box-shadow: 0 0 14px #73c2e9;
  }
  #menu, #skinsMenu, #restartMenu, #pauseMenu {
    position: fixed;
    top:50%; left:50%;
    transform: translate(-50%, -50%);
    background: rgba(20,20,40,0.95);
    border-radius: 15px;
    padding: 30px 40px;
    text-align: center;
    box-shadow: 0 0 30px #00fff7;
    color: #00fff7;
    display: none;
    min-width: 280px;
    user-select:none;
  }
  #skinsMenu button.skin-btn {
    margin: 5px;
    width: 50px; height: 50px;
    border-radius: 50%;
    border: 2px solid #00fff7;
  }
  #skinsMenu button.skin-btn.selected {
    box-shadow: 0 0 15px 3px #00fff7;
  }
  canvas {
    display:block; margin:0 auto;
    background: transparent;
  }
  #flashOverlay {
    position: fixed;
    top:0; left:0; width: 100vw; height: 100vh;
    pointer-events:none;
    background: rgba(255,0,0,0.4);
    display: none;
    mix-blend-mode: screen;
    z-index: 1000;
  }
  #pauseBtn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(74, 161, 176, 0.7);
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 0 10px #4AA1B0;
    z-index: 100;
    display: none;
  }
  #pauseBtn:hover {
    background: rgba(115, 194, 233, 0.7);
    box-shadow: 0 0 14px #73c2e9;
  }
  .power-up-indicator {
    position: fixed;
    bottom: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
  }
  .power-up-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: white;
    text-shadow: 0 0 5px black;
  }
  .power-up-icon.active {
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 10px white;
  }
  .power-up-icon.shield { background: rgba(0, 200, 255, 0.7); }
  .power-up-icon.slow { background: rgba(255, 100, 0, 0.7); }
  .power-up-icon.speed { background: rgba(0, 255, 100, 0.7); }
</style>
</head>
<body>

<div id="info">
  <div id="hearts"></div>
  <div id="time">Time: 0s</div>
  <div id="highScore">High Score: 0s</div>
</div>

<div id="menu">
  <h1>Boat Racer</h1>
  <button id="playBtn">Play</button><br/>
  <button id="skinsBtn">Skins</button>
</div>

<div id="skinsMenu">
  <h2>Select Your Boat Skin</h2>
  <div id="skinOptions"></div>
  <button id="skinsBackBtn">Back</button>
</div>

<div id="restartMenu">
  <h1>Game Over!</h1>
  <p id="finalScore">Your Time: 0s</p>
  <p id="bestScore">Best Time: 0s</p>
  <button id="restartBtn">Restart</button><br/>
  <button id="backToMenuBtn">Main Menu</button>
</div>

<div id="pauseMenu">
  <h1>Game Paused</h1>
  <button id="continueBtn">Continue</button><br/>
  <button id="pauseToMenuBtn">Main Menu</button>
</div>

<div id="flashOverlay"></div>

<button id="pauseBtn">‚è∏</button>

<div class="power-up-indicator">
  <div class="power-up-icon shield" title="Shield">üõ°Ô∏è</div>
  <div class="power-up-icon slow" title="Slow Motion">üêå</div>
  <div class="power-up-icon speed" title="Health Boost">‚ù§Ô∏è</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  
  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // DOM elements
  const infoTime = document.getElementById('time');
  const infoHighScore = document.getElementById('highScore');
  const heartsContainer = document.getElementById('hearts');
  const menu = document.getElementById('menu');
  const playBtn = document.getElementById('playBtn');
  const skinsBtn = document.getElementById('skinsBtn');
  const skinsMenu = document.getElementById('skinsMenu');
  const skinOptionsDiv = document.getElementById('skinOptions');
  const skinsBackBtn = document.getElementById('skinsBackBtn');
  const restartMenu = document.getElementById('restartMenu');
  const finalScoreP = document.getElementById('finalScore');
  const bestScoreP = document.getElementById('bestScore');
  const restartBtn = document.getElementById('restartBtn');
  const backToMenuBtn = document.getElementById('backToMenuBtn');
  const flashOverlay = document.getElementById('flashOverlay');
  const pauseBtn = document.getElementById('pauseBtn');
  const pauseMenu = document.getElementById('pauseMenu');
  const continueBtn = document.getElementById('continueBtn');
  const pauseToMenuBtn = document.getElementById('pauseToMenuBtn');
  const powerUpIndicators = document.querySelectorAll('.power-up-icon');

  // Game state
  let lives = 3;
  const maxLives = 3;
  let distance = 0;
  let startTime = 0;
  let gameOver = false;
  let obstacles = [];
  let powerUps = [];
  let lastSpawn = 0;
  let spawnInterval = 2500;
  let difficultyIncreaseInterval = 30000;
  let lastDifficultyIncrease = 0;
  let obstacleSpeed = 2.5;
  let maxObstacles = 3;
  
  // Power-up spawn settings
  let powerUpSpawnChance = 0.006; // Reduced from 0.008
  const powerUpTypeChances = {
    shield: 0.4,  // 40% chance
    slow: 0.4,    // 40% chance
    speed: 0.2    // 20% chance (hearts)
  };
  
  let flashing = false;
  let flashTime = 0;
  let flashDuration = 300;
  let highScore = 0;
  let gamePaused = false;
  let pauseTime = 0;
  let pauseDuration = 0;

  // Power-up states
  let hasShield = false;
  let slowMotionActive = false;
  let powerUpEndTime = {
    slow: 0
  };
  const powerUpDuration = 5000;

  // Boat settings and skins
  const boatSkins = [
    {color: '#E63946', name: 'Red'},
    {color: '#457B9D', name: 'Blue'},
    {color: '#2A9D8F', name: 'Teal'},
    {color: '#F4A261', name: 'Orange'},
    {color: '#6A4C93', name: 'Purple'}
  ];
  let currentSkinIndex = 0;

  const boat = {
    w: 60,
    h: 90,
    x: 0,
    y: 0,
    speed: 6,
    baseSpeed: 6,
    color: boatSkins[0].color
  };

  function resetBoat(){
    boat.x = canvas.width/2 - boat.w/2;
    boat.y = canvas.height - boat.h - 100;  // Changed from -30 to -100 to move boat up
    boat.color = boatSkins[currentSkinIndex].color;
    boat.speed = boat.baseSpeed;
  }

  // Touch control
  let touchX = null;
  canvas.addEventListener('touchstart', e => { touchX = e.touches[0].clientX; }, {passive:false});
  canvas.addEventListener('touchmove', e => { e.preventDefault(); touchX = e.touches[0].clientX; }, {passive:false});
  canvas.addEventListener('touchend', () => { touchX = null; });

  // Keyboard control fallback
  let keys = {};
  window.addEventListener('keydown', e => { 
    keys[e.key] = true; 
    if(e.key === 'Escape') togglePause();
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // Power-up class
  class PowerUp {
    constructor(type, x, y) {
      this.type = type;
      this.x = x;
      this.y = y;
      this.size = 30;
      this.speed = 2;
      this.collected = false;
      
      switch(type) {
        case 'shield':
          this.color = '#00a8ff';
          this.symbol = 'üõ°Ô∏è';
          break;
        case 'slow':
          this.color = '#fbc531';
          this.symbol = 'üêå';
          break;
        case 'speed':
          this.color = '#4cd137';
          this.symbol = '‚ù§Ô∏è';
          break;
      }
    }
    
    update() {
      this.y += this.speed;
    }
    
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      
      ctx.beginPath();
      ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(0, 0, this.size/2 - 5, 0, Math.PI * 2);
      ctx.fillStyle = 'white';
      ctx.fill();
      
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.color;
      ctx.fillText(this.symbol, 0, 0);
      
      ctx.restore();
    }
    
    getBounds() {
      return {
        x: this.x - this.size/2,
        y: this.y - this.size/2,
        width: this.size,
        height: this.size
      };
    }
    
    activate() {
      this.collected = true;
      const now = Date.now();
      
      switch(this.type) {
        case 'shield':
          hasShield = true;
          updatePowerUpIndicators();
          break;
        case 'slow':
          slowMotionActive = true;
          powerUpEndTime.slow = now + powerUpDuration;
          break;
        case 'speed':
          // Add one heart (up to max)
          if (lives < maxLives) {
            lives++;
            updateHearts();
          }
          break;
      }
      
      updatePowerUpIndicators();
    }
  }

  // Obstacle class
  class Obstacle {
    constructor(x, y, speed){
      this.x = x;
      this.y = y;
      this.speed = speed;
      this.size = 20 + Math.random()*30;
      const shapes = ['circle', 'square', 'triangle'];
      this.shape = shapes[Math.floor(Math.random()*shapes.length)];
      const colors = ['#FFD166', '#06D6A0', '#118AB2', '#EF476F', '#FFC43D', '#8338EC'];
      this.color = colors[Math.floor(Math.random()*colors.length)];
      this.angle = 0;
      this.rotationSpeed = (Math.random() - 0.5) * 0.05;
      
      this.movementPattern = Math.random() > 0.7 ? 
        (Math.random() > 0.5 ? 'zigzag' : 'following') : 'normal';
      
      this.zigzagSpeed = Math.random() * 2 + 1;
      this.zigzagDirection = Math.random() > 0.5 ? 1 : -1;
      
      this.followSpeed = Math.random() * 0.5 + 0.5;
      this.followDelay = Math.random() * 1000 + 500;
      this.followStartTime = Date.now() + this.followDelay;
    }
    
    update(){
      const effectiveSpeed = slowMotionActive ? this.speed * 0.3 : this.speed;
      
      this.y += effectiveSpeed;
      this.angle += this.rotationSpeed;
      
      switch(this.movementPattern) {
        case 'zigzag':
          this.x += this.zigzagSpeed * this.zigzagDirection;
          if(this.x < this.size/2 || this.x > canvas.width - this.size/2) {
            this.zigzagDirection *= -1;
          }
          break;
          
        case 'following':
          if(Date.now() > this.followStartTime) {
            const dx = boat.x + boat.w/2 - this.x;
            this.x += Math.sign(dx) * this.followSpeed;
          }
          break;
      }
    }
    
    draw(){
      ctx.fillStyle = this.color;
      ctx.save();
      ctx.translate(this.x, this.y);
      if(this.shape === 'circle'){
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2, 0, 2*Math.PI);
        ctx.fill();
      } else if(this.shape === 'square'){
        ctx.rotate(this.angle);
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
      } else if(this.shape === 'triangle'){
        ctx.rotate(this.angle);
        ctx.beginPath();
        ctx.moveTo(0, -this.size/2);
        ctx.lineTo(this.size/2, this.size/2);
        ctx.lineTo(-this.size/2, this.size/2);
        ctx.closePath();
        ctx.fill();
      }
      
      if(this.movementPattern !== 'normal') {
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2 + 5, 0, Math.PI * 2);
        ctx.strokeStyle = this.movementPattern === 'zigzag' ? '#f39c12' : '#e74c3c';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    getBounds(){
      return {
        x: this.x - this.size/2,
        y: this.y - this.size/2,
        width: this.size,
        height: this.size
      };
    }
  }

  function isCollide(b, o){
    return !(b.x > o.x+o.width || b.x+b.w < o.x || b.y > o.y+o.height || b.y+b.h < o.y);
  }

  function drawBoat(){
    ctx.save();
    ctx.translate(boat.x + boat.w/2, boat.y + boat.h/2);
    const angle = Math.sin(Date.now()/300) * 0.1;
    ctx.rotate(angle);
    
    if(hasShield) {
      ctx.beginPath();
      ctx.arc(0, 0, Math.max(boat.w, boat.h)/2 + 10, 0, Math.PI * 2);
      ctx.strokeStyle = '#00a8ff';
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    
    ctx.fillStyle = boat.color;
    ctx.beginPath();
    ctx.moveTo(-boat.w/2, boat.h/2);
    ctx.lineTo(-boat.w/3, -boat.h/2);
    ctx.lineTo(boat.w/3, -boat.h/2);
    ctx.lineTo(boat.w/2, boat.h/2);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#00fff7';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-boat.w/4, boat.h/3);
    ctx.lineTo(boat.w/4, boat.h/3);
    ctx.stroke();
    ctx.fillStyle = '#0ff';
    ctx.fillRect(-boat.w/10, boat.h/6, boat.w/5, boat.h/12);
    ctx.restore();
  }

  function updateHearts(){
    heartsContainer.innerHTML = '';
    for(let i=0; i<maxLives; i++){
      const heart = document.createElement('div');
      heart.classList.add('heart');
      if(i >= lives) heart.classList.add('lost');
      heartsContainer.appendChild(heart);
    }
  }

  function triggerFlash(){
    flashing = true;
    flashTime = Date.now();
    flashOverlay.style.display = 'block';
  }
  
  function updateFlash(){
    if(flashing && Date.now() - flashTime > flashDuration){
      flashing = false;
      flashOverlay.style.display = 'none';
    }
  }

  function updatePowerUpIndicators() {
    const now = Date.now();
    
    powerUpIndicators[0].classList.toggle('active', hasShield);
    powerUpIndicators[1].classList.toggle('active', slowMotionActive && now < powerUpEndTime.slow);
    powerUpIndicators[2].classList.toggle('active', false); // Health boost has no active state
  }

  function checkPowerUpExpiration() {
    const now = Date.now();
    
    if(slowMotionActive && now > powerUpEndTime.slow) {
      slowMotionActive = false;
    }
    
    updatePowerUpIndicators();
  }

  function spawnPowerUp() {
    if(Math.random() < powerUpSpawnChance && powerUps.length < 1) {
      // Determine which type of power-up to spawn
      const rand = Math.random();
      let type;
      
      if (rand < powerUpTypeChances.shield) {
        type = 'shield';
      } else if (rand < powerUpTypeChances.shield + powerUpTypeChances.slow) {
        type = 'slow';
      } else {
        type = 'speed'; // Heart power-up
      }
      
      const x = Math.random() * (canvas.width - 60) + 30;
      powerUps.push(new PowerUp(type, x, -50));
    }
  }

  function increaseDifficulty() {
    spawnInterval = Math.max(800, spawnInterval - 100);
    obstacleSpeed += 0.3;
    maxObstacles = Math.min(8, maxObstacles + 1);
    powerUpSpawnChance = Math.min(0.015, powerUpSpawnChance + 0.001);
  }

  function togglePause(){
    if(gameOver) return;
    
    gamePaused = !gamePaused;
    
    if(gamePaused) {
      pauseTime = Date.now();
      cancelAnimationFrame(animationFrameId);
      pauseMenu.style.display = 'block';
      pauseBtn.textContent = '‚ñ∂';
    } else {
      pauseDuration += Date.now() - pauseTime;
      pauseMenu.style.display = 'none';
      pauseBtn.textContent = '‚è∏';
      loop();
    }
  }

  let animationFrameId;

  function resetGame(){
    lives = maxLives;
    distance = 0;
    startTime = Date.now();
    gameOver = false;
    obstacles = [];
    powerUps = [];
    lastSpawn = 0;
    lastDifficultyIncrease = 0;
    spawnInterval = 2500;
    obstacleSpeed = 2.5;
    maxObstacles = 3;
    powerUpSpawnChance = 0.006;
    pauseDuration = 0;
    
    hasShield = false;
    slowMotionActive = false;
    boat.speed = boat.baseSpeed;
    updatePowerUpIndicators();
    
    resetBoat();
    updateHearts();
    updateInfo();
    loop();
  }

  function updateInfo(){
    const elapsed = Math.floor((Date.now()-startTime - pauseDuration)/1000);
    infoTime.textContent = `Time: ${elapsed}s`;
    if(elapsed > highScore) {
      highScore = elapsed;
      localStorage.setItem('boatRacerHighScore', highScore);
    }
    infoHighScore.textContent = `High Score: ${highScore}s`;
  }

  function spawnObstacle(){
    const x = Math.random() * (canvas.width - 60) + 30;
    obstacles.push(new Obstacle(x, -50, obstacleSpeed));
  }

  function update(){
    if(gameOver || gamePaused) return;

    const now = Date.now();

    if(now - lastSpawn > spawnInterval && obstacles.length < maxObstacles){
      lastSpawn = now;
      spawnObstacle();
    }
    
    spawnPowerUp();

    if(now - lastDifficultyIncrease > difficultyIncreaseInterval){
      lastDifficultyIncrease = now;
      increaseDifficulty();
    }

    obstacles.forEach((o, i) => {
      o.update();
      if(o.y - o.size/2 > canvas.height){
        obstacles.splice(i, 1);
        distance += 100;
      } else if(isCollide(boat, o.getBounds())){
        obstacles.splice(i, 1);
        
        if(hasShield) {
          hasShield = false;
          updatePowerUpIndicators();
        } else {
          lives--;
          updateHearts();
          triggerFlash();
          if(lives <= 0) {
            gameOver = true;
            cancelAnimationFrame(animationFrameId);
            showRestartMenu();
          }
        }
      }
    });
    
    powerUps.forEach((p, i) => {
      p.update();
      if(p.y - p.size/2 > canvas.height) {
        powerUps.splice(i, 1);
      } else if(!p.collected && isCollide(boat, p.getBounds())) {
        p.activate();
        powerUps.splice(i, 1);
      }
    });
    
    checkPowerUpExpiration();

    if(touchX !== null){
      const targetX = touchX - boat.w/2;
      const dx = targetX - boat.x;
      boat.x += Math.sign(dx) * Math.min(Math.abs(dx), boat.speed);
    } else {
      if(keys['ArrowLeft'] || keys['a']) boat.x -= boat.speed;
      if(keys['ArrowRight'] || keys['d']) boat.x += boat.speed;
    }
    boat.x = Math.min(Math.max(0, boat.x), canvas.width - boat.w);

    updateFlash();
    updateInfo();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBoat();
    obstacles.forEach(o => o.draw());
    powerUps.forEach(p => p.draw());
  }

  function loop(){
    update();
    draw();
    if(!gameOver && !gamePaused) animationFrameId = requestAnimationFrame(loop);
  }

  function showMainMenu(){
    menu.style.display = 'block';
    skinsMenu.style.display = 'none';
    restartMenu.style.display = 'none';
    pauseMenu.style.display = 'none';
    canvas.style.display = 'none';
    flashOverlay.style.display = 'none';
    pauseBtn.style.display = 'none';
  }
  
  function showSkinsMenu(){
    menu.style.display = 'none';
    skinsMenu.style.display = 'block';
    restartMenu.style.display = 'none';
    pauseMenu.style.display = 'none';
    canvas.style.display = 'none';
    pauseBtn.style.display = 'none';
  }
  
  function showRestartMenu(){
    menu.style.display = 'none';
    skinsMenu.style.display = 'none';
    restartMenu.style.display = 'block';
    pauseMenu.style.display = 'none';
    canvas.style.display = 'none';
    flashOverlay.style.display = 'none';
    pauseBtn.style.display = 'none';

    const elapsed = Math.floor((Date.now()-startTime - pauseDuration)/1000);
    finalScoreP.textContent = `Your Time: ${elapsed}s`;
    bestScoreP.textContent = `Best Time: ${highScore}s`;
  }
  
  function showGameCanvas(){
    menu.style.display = 'none';
    skinsMenu.style.display = 'none';
    restartMenu.style.display = 'none';
    pauseMenu.style.display = 'none';
    canvas.style.display = 'block';
    pauseBtn.style.display = 'block';
  }

  function initSkinButtons(){
    skinOptionsDiv.innerHTML = '';
    boatSkins.forEach((skin, idx) => {
      const btn = document.createElement('button');
      btn.classList.add('skin-btn');
      btn.style.background = skin.color;
      if(idx === currentSkinIndex) btn.classList.add('selected');
      btn.title = skin.name;
      btn.addEventListener('click', () => {
        currentSkinIndex = idx;
        const btns = skinOptionsDiv.querySelectorAll('button');
        btns.forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        boat.color = boatSkins[currentSkinIndex].color;
        resetBoat();
      });
      skinOptionsDiv.appendChild(btn);
    });
  }

  // Button event listeners
  playBtn.addEventListener('click', () => {
    resetGame();
    showGameCanvas();
  });

  skinsBtn.addEventListener('click', () => {
    initSkinButtons();
    showSkinsMenu();
  });

  skinsBackBtn.addEventListener('click', () => {
    showMainMenu();
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
    showGameCanvas();
  });

  backToMenuBtn.addEventListener('click', () => {
    showMainMenu();
  });

  pauseBtn.addEventListener('click', togglePause);

  continueBtn.addEventListener('click', togglePause);

  pauseToMenuBtn.addEventListener('click', () => {
    togglePause();
    showMainMenu();
  });

  // Load high score from localStorage
  if(localStorage.getItem('boatRacerHighScore')) {
    highScore = parseInt(localStorage.getItem('boatRacerHighScore'));
    infoHighScore.textContent = `High Score: ${highScore}s`;
  }

  // Start showing main menu initially
  showMainMenu();

})();
</script>
</body>
</html>